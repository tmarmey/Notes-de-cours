\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\graphicspath{{../Images/}}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage[margin=1in]{geometry}
\usepackage{ulem}
\usepackage{subfig}
\usepackage{float}
\usepackage{xcolor}
\hypersetup{
    linktoc=all,     %set to all if you want both sections and subsections linked
    linkcolor=blue,  %choose some color if you want links to stand out
}
\usepackage{listings}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  backgroundcolor=\color[rgb]{0.9,0.9,0.9},
  language=C++,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
  }

\author{Thibaut Marmey}

\title{Notes de cours C++}
\begin{document}
	\maketitle

\begin{normalsize}
\tableofcontents
\end{normalsize}

\section{Programmation C++}
\subsection{L'héritage}
\begin{itemize}
\item \href{https://openclassrooms.com/fr/courses/1894236-programmez-avec-le-langage-c/1898475-lheritage}{Cours openclassroom : héritage}
\item Déclaration d'une classe héréditaire : 
\begin{lstlisting}
class Classe_fille : public|protected|private Classe_mere1
[, public|protected|private Classe_mere2 [...]]
{
    /* Definition de la classe fille. */
};
\end{lstlisting}
\item les données publiques d'une classe mère deviennent soit publiques, soit protégées, soit privées selon que la classe fille hérite en public, protégé ou en privé.
\item La classe fille possède les attributs et les méthodes de la classe mère. Elle possède en plus de cela ses propres attributs et méthodes
\item Possibilité de surcharger les méthodes de la classe mère dans la classe fille
\item Surcharge du constructeur : on peut appeler le constructeur de la classe mère dans le constructeur de la classe fille.
\newline Pour déclarer un constructeur dans le .h : il doit avoir le même nom que la calsse, et il ne doit rien renvoyer. \textit{maClasse()}
\newline On écrira aussi le constructeur dans le .cpp de la manière suivante : 
\newline \textit{maClasse::maClasse() : blaba, bla, bla \{ \}}
\item Masquage de fonctions de la classe mère. On peut substituer le nom d'une fonction présente dans la classe mère et utiliser sous le même nom une méthode spécifique dans une classe fille. On peut toujours appeler la méthode de la classe mère dans la méthode de la classe fille en spécifiant l'appel à la classe mère grâce au double deux points "nomClasseMere::nomMéthode()".
\item Dérivation de type : on peut substituer un objet de la classe fille à un pointeur ou une référence vers un objet de la classe mère. On peut affecter un élément enfant à un élément parent
\newline Il est possible d'écrire \textit{monPersonnage = monGuerrier} car un guerrier est un personnage. L'inverse n'est pas possible \sout{\textit{monGuerrier = monPersonnage}}
\item La dériation de type est très pratique dans l'appel d'un élément dans une fonction par exemple. Si l'argument à mettre est de la classe \textit{Personnage} il est alors possible de mettre tous les autres classes filles de \textit{Personnage}
\newline \textit{void coupDePoing(Personnage} \& \textit{cible) const;} : \textit{cible} peut être de type \textit{Personnage} ou \textit{Guerrier}
\item Le type \textit{protected} permet aux attributs d'être accessible par les classes filles et inaccessible de l'extérieur
\end{itemize}

\subsection{Polymorphisme}
\begin{itemize}
\item  le polymorphisme est un mécanisme dynamique permettant, par voie d'héritage, de spécialiser dans des classes dérivées les comportements annoncés ou implémentés dans des classes de base, indirectes ou non.
\item \textbf{Résolution statique des liens.} La fonction reçoit un type de data, c'est donc toujours les méthodes de ce type qui sera utilisée. C'est donc le type de la variable qui détermine quelle fonction membre appeler et non sa vraie nature.\\
\textit{Ex pratique : } 
\newline void presenter(Vehicule v)  //Présente le véhicule passé en argument
\newline \{  v.affiche(); \}
\newline La fonction reçoit un véhicule (classe mère) c’est donc les méthodes de véhicule qui sont appelées même si une surcharge de méthode est présente dans la classe fille.
\item \textbf{Réolution dynamique des liens.} Lors de l'exécution le programme utilise la bonne version des méthodes car il sait si l'objet est de type mère ou type fille.
\begin{itemize}
\item utiliser un pointeur ou une référence
\item utiliser des méthodes virtuelles
\end{itemize}
\item Il faut placer un pointeur ou une référence comme argument dans la fonction \textit{void presenter(Vehicule const\& v)}
\item Rajouter \textit{virtual} devant la méthode dans la classe mère (seulement dans le .h) et c’est optionnel dans les classes filles.
\end{itemize}

\subsection{Design Pattern}
\begin{itemize}
\item Ce sont des modèles théoriques adaptables qui résolvent un problème précis.
\item \textbf{Un prototype :} un prototype est une classe dont le but est d'être clonée. 
\item \textbf{Le singleton :} permet de s'assurer qu'il n'existe qu'une unique instance d'une classe donnée. \\
Est une variable globale.
\item \textbf{La fabrique :} classe dont le rôle est de créer d'autres objets.
\item \textbf{Les décorateurs :} sont l'ensemble des classes permettant d'étendre dynamiquement le rôle d'une classe de base.
\end{itemize}

\subsection{Template}
\begin{itemize}
\item Les templates sont des fonctions spéciales qui peuvent être utilisées avec des types génériques. Cela nous permet de créer une fonction template dont l'utilisation n'est pas réstreinte à un seul type de données, sans répéter le code entier pour chaque type.
\begin{lstlisting}
template <class myType>
myType GetMax (myType a, myType b) {
 return (a>b?a:b); }
\end{lstlisting}
\item Pour utiliser les fonctions templates on utilise le schéma suivant :
\begin{lstlisting}
//function_name <type> (parameters);
int x,y;
GetMax <int> (x,y);
\end{lstlisting}
\item Utilisation des templates avec les classes :
\begin{lstlisting}
template <class T>
class mypair {
    T a, b;
  public:
    mypair (T first, T second)
      {a=first; b=second;}
    T getmax ();
};

template <class T> //T for template parameter
T mypair<T>::getmax () //1st T for the type return by the function
//2nd T for requirement to specify the function's template parameter
{
  T retval;
  retval = a>b? a : b;
  return retval;
}
\end{lstlisting}
\end{itemize}

\subsection{Autre}
\begin{itemize}
\item Utilisation de $=$ dans un \textit{if}.
\begin{lstlisting}
int a = 1
int b = 2;
if ((a=b)) {...} //is true
blabla...
int b = 0;
if ((a=b)) {...} //is false
\end{lstlisting}
\item Utilisation de \textit{auto} (C++11) : cet outil permet de spécifier automatiquement le type de la variable en jeu. 
\newline \textit{ex : auto x = 1; auto y = 3.1; auto z = 'a';}
\newline \textit{output : x est int, y est double, z est char}
\item \textit{Lambda} function : \textit{ex : auto allowed = [\&](int x, const std::vector$\langle$int$\rangle$\&vect)\{...\}}
\begin{itemize}
\item a. [=] capture all variables within scope by value
\item b. [\&] capture all variables within scope by reference
\item c. [\& var] capture var by reference
\item d. [\&, var] specify that the default way of capturing is by reference and we want to capture var
\item e. [=, \& var] capture the variables in scope by value by default, but capture var using reference instead
\end{itemize}
\end{itemize}

\end{document}