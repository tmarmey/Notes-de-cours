\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\graphicspath{{../Images/}}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage[margin=1in]{geometry}
\usepackage{ulem}
\usepackage{subfig}
\usepackage{float}

\author{Thibaut Marmey}

\title{Notes de cours C++}
\begin{document}
	\maketitle

\begin{normalsize}
\tableofcontents
\end{normalsize}

\section{Programmation C++}
\subsection{L'héritage}
\begin{itemize}
\item \href{https://openclassrooms.com/fr/courses/1894236-programmez-avec-le-langage-c/1898475-lheritage}{Cours openclassroom : héritage}
\item Déclaration d'une classe héréditaire : \textit{class Guerrier : public Personnage \{ ... \}}
\newline La classe \textit{Guerrier} hérite de la classe \textit{Personnage}.
\item La classe fille possède les attributs et les méthodes de la classe mère. Elle possède en plus de cela ses propres attributs et méthodes
\item Possibilité de surcharger les méthodes de la classe mère dans la classe fille
\item Surcharge du constructeur : on peut appeler le constructeur de la classe mère dans le constructeur de la classe fille.
\newline Pour déclarer un constructeur dans le .h : il doit avoir le même nom que la calsse, et il ne doit rien renvoyer. \textit{maClasse()}
\newline On écrira aussi le constructeur dans le .cpp de la manière suivante : 
\newline \textit{maClasse::maClasse() : blaba, bla, bla \{ \}}
\item Masquage de fonctions de la classe mère. On peut substituer le nom d'une fonction présente dans la classe mère et utiliser sous le même nom une méthode spécifique dans une classe fille. On peut toujours appeler la méthode de la classe mère dans la méthode de la classe fille en spécifiant l'appel à la classe mère grâce au double deux points "nomClasseMere::nomMéthode()".
\item Dérivation de type : on peut substituer un objet de la classe fille à un pointeur ou une référence vers un objet de la classe mère. On peut affecter un élément enfant à un élément parent
\newline Il est possible d'écrire \textit{monPersonnage = monGuerrier} car un guerrier est un personnage. L'inverse n'est pas possible \sout{\textit{monGuerrier = monPersonnage}}
\item La dériation de type est très pratique dans l'appel d'un élément dans une fonction par exemple. Si l'argument à mettre est de la classe \textit{Personnage} il est alors possible de mettre tous les autres classes filles de \textit{Personnage}
\newline \textit{void coupDePoing(Personnage} \& \textit{cible) const;} : \textit{cible} peut être de type \textit{Personnage} ou \textit{Guerrier}
\item Le type \textit{protected} permet aux attributs d'être accessible par les classes filles et inaccessible de l'extérieur
\end{itemize}

\subsection{Polymorphisme}
\begin{itemize}
\item Résolution statique des liens. \textit{Ex pratique : } 
\newline void presenter(Vehicule v)  //Présente le véhicule passé en argument
\newline \{  v.affiche(); \}
\newline La fonction reçoit un véhicule (classe mère) c’est donc les méthodes de véhicule qui sont appelées même si une surcharge de méthode est présente dans la classe fille.
Pour régler ce problème il faut deux choses :
\begin{itemize}
\item utiliser un pointeur ou une référence
\item utiliser des méthodes virtuelles
\end{itemize}
Il faut placer un pointeur ou une référence comme argument dans la fonction \textit{void presenter(Vehicule const\& v)}
\newline Rajouter \textit{virtual} devant la méthode dans la classe mère et c’est optionnel dans les classes filles.
\end{itemize}

\subsection{Autre}
\begin{itemize}
\item Utilisation de \textit{auto} (C++11) : cet outil permet de spécifier automatiquement le type de la variable en jeu. 
\newline \textit{ex : auto x = 1; auto y = 3.1; auto z = 'a';}
\newline \textit{output : x est int, y est double, z est char}
\item \textit{Lambda} function : \textit{ex : auto allowed = [\&](int x, const std::vector$\langle$int$\rangle$\&vect)\{...\}}
\begin{itemize}
\item a. [=] capture all variables within scope by value
\item b. [\&] capture all variables within scope by reference
\item c. [\& var] capture var by reference
\item d. [\&, var] specify that the default way of capturing is by reference and we want to capture var
\item e. [=, \& var] capture the variables in scope by value by default, but capture var using reference instead
\end{itemize}
\end{itemize}

\end{document}